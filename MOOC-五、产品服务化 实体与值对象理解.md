#### Question

+ Typora 如何同步文章到Github
+ <http://whuhan2013.github.io/blog/2015/09/19/markdown-simple-grammar/>
+ http://www.april1985.com 关于重读书的收获
 

#### 产品定义

+ 产品： 1+1=2 简单 1+1=11  ，1+1 =1 1个平台  

 #### 软件包

+ 认识软件包
+ 软件包场景
+ 软件包选型

  现在对软件包的理解，不仅仅是一个大的软件包，而且也可以是一个独立的服务

#### 产品服务化

+ DDD的诞生和定义
+ 统一语言的重要性
+ 实体和值对象建模
+ 限界上下文识别
+ 领域事件和命令
   **做这些识别和我们的服务化有什么明显的关系呢**

#### DDD在美团点评业务中的实践

​    业务的演进是从简单到复杂，随着迭代的申请，模块之间彼此关联，模块职责不清晰，导致修改一个功能点，需要回溯同步修改的地方要很长时间，而且还不知道带来的相关影响性，出现常常说的系统架构不清晰，模块内聚底，高耦合。所以提出演进式的设计理论，通过持续的重构来让系统系统随业务生长二变化，那么对于重构的层级上，往往是一个单独类和单独的方法这一个层面，还是会导致架构腐化，

​    常见的贫血模型 ，仅仅是数据的载体，没有行为和动作的领域对象，早期的J2EE ,Action Service Dao 的分层代码，带来过多的过程式的数据，以数据为中的的驱动设计

**复杂问题的解决方法，不论是软件还是日常生活**

​	抽象、分治、知识，只是是一种方法论 ，换成另外一种思路，强调的是颗粒对大小的划分和降低耦合度，粒度的调整降低团队认知的负担，更容易达成一致，敏捷的团队也是如此含义，包括Feature ，Story的出现，

​	抽象能是的问题精简，问题越小，大家理解起来就越简单

+ 分治 把问题空间分割为规模更小且易于处理的若干子问题。分割后的问题需要足够小，以便一个人单枪匹马就能够解决他们；其次，必须考虑如何将分割后的各个部分装配为整体。分割得越合理越易于理解，在装配成整体时，所需跟踪的细节也就越少。即更容易设计各部分的协作方式。评判什么是分治得好，即高内聚低耦合。
+ 抽象 使用抽象能够精简问题空间，而且问题越小越容易理解。举个例子，从北京到上海出差，可以先理解为使用交通工具前往，但不需要一开始就想清楚到底是高铁还是飞机，以及乘坐他们需要注意什么。
+ 知识 顾名思义，DDD可以认为是知识的一种。

   DDD提供了这样的知识手段，让我们知道如何抽象出限界上下文以及如何去分治。分治可以从技术维度，也可以从业务维度处理

   ​参考的网站<https://yq.aliyun.com/articles/319159>

如何开始实践DDD：

​	根据需求，初步划分 领域（核心域、支撑子域、通用域）、限界上下文、及上下文之间的关系

​	然后每个域之内的实体、值对象、识别这些领域对象的关联和聚合，识别出聚合范畴和聚合根，根据聚合根设计仓储

 现实世界的，领域包括：问题域和解决域两大部分

**一个由显示边界限定的特定职责。领域模型便存在于这个边界之内。在边界内，每一个模型概念，包括它的属性和操作，都具有特殊的含义。**

一个给定的业务领域会包含多个限界上下文，想与一个限界上下文沟通，则需要通过显示边界进行通信。系统通过确定的限界上下文来进行解耦，而每一个上下文内部紧密组织，职责明确，具有较高的内聚性。

一个很形象的隐喻：细胞质所以能够存在，是因为细胞膜限定了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜。

**限界上下文有常用的几种关系**，通过一张图可以很好说明，领域之间的沟通成本和影响程度的划分

- 合作关系（Partnership）：两个上下文紧密合作的关系，一荣俱荣，一损俱损。
- 共享内核（Shared Kernel）：两个上下文依赖部分共享的模型。
- 客户方-供应方开发（Customer-Supplier Development）：上下文之间有组织的上下游依赖。
- 遵奉者（Conformist）：下游上下文只能盲目依赖上游上下文。
- 防腐层（Anticorruption Layer）：一个上下文通过一些适配和转换与另一个上下文交互。
- 开放主机服务（Open Host Service）：定义一种协议来让其他上下文来对本上下文进行访问。
- 发布语言（Published Language）：通常与OHS一起使用，用于定义开放主机的协议。
- 大泥球（Big Ball of Mud）：混杂在一起的上下文关系，边界不清晰。
- 另谋他路（SeparateWay）：两个完全没有任何联系的上下文。


#### 战术建模实体值对象

​    我们很容易的将实体对应的物理表的映射，其实他们也有很多的相似。也许应该从代码层面上来理解实体与值对象的设计和开发时候的好处

**实体**：强调的是对现实生活的对象进行抽象，强调是通过标识来识别唯一性，又识别的实体在其生命周期内是连续的和唯一性

**值对象**：不需要标识的领域概念，不用关心对象是哪个，只关心对象是什么，有点像 int  a=3  ,那值对象到底有没有唯一标识呢？也许有，但没有用

​	实体和值对象的识别是在有限的上下文之间的定义，不同的业务领域会互相转化，值对象对分布式友好，所以管理起来简单，

**实体**

当一个对象由其标识（而不是属性）区分时，这种对象称为实体（Entity）。

例：最简单的，公安系统的身份信息录入，对于人的模拟，即认为是实体，因为每个人是独一无二的，且其具有唯一标识（如公安系统分发的身份证号码）。

在实践上建议将属性的验证放到实体中。

**值对象**

当一个对象用于对事务进行描述而没有唯一标识时，它被称作值对象（Value Object）。

例：比如颜色信息，我们只需要知道{"name":"黑色"，"css":"#000000"}这样的值信息就能够满足要求了，这避免了我们对标识追踪带来的系统复杂性。

值对象很重要，在习惯了使用数据库的数据建模后，很容易将所有对象看作实体。使用值对象，可以更好地做系统优化、精简设计。

它具有不变性、相等性和可替换性。

在实践中，需要保证值对象创建后就不能被修改，即不允许外部再修改其属性。在不同上下文集成时，会出现模型概念的公用，如商品模型会存在于电商的各个上下文中。在订单上下文中如果你只关注下单时商品信息快照，那么将商品对象视为值对象是很好的选择。

​	值对象有部分的含义是通过冗余的存储来解决，访问的复杂和耦合，谨慎使用值对象，在实践中，我们发现虽然一些领域对象符合值对象的概念，但是随着业务的变动，很多原有的定义会发生变更，值对象可能需要在业务意义具有唯一标识，而对这类值对象的重构往往需要较高成本。因此在特定的情况下，我们也要根据实际情况来权衡领域对象的选型

**聚合根**

Aggregate(聚合）是一组相关对象的集合，作为一个整体被外界访问，聚合根（Aggregate Root）是这个聚合的根节点。

聚合是一个非常重要的概念，核心领域往往都需要用聚合来表达。其次，聚合在技术上有非常高的价值，可以指导详细设计。

聚合由根实体，值对象和实体组成。

如何创建好的聚合？

- 边界内的内容具有一致性：在一个事务中只修改一个聚合实例。如果你发现边界内很难接受强一致，不管是出于性能或产品需求的考虑，应该考虑剥离出独立的聚合，采用最终一致的方式。
- 设计小聚合：大部分的聚合都可以只包含根实体，而无需包含其他实体。即使一定要包含，可以考虑将其创建为值对象。
- 通过唯一标识来引用其他聚合或实体：当存在对象之间的关联时，建议引用其唯一标识而非引用其整体对象。如果是外部上下文中的实体，引用其唯一标识或将需要的属性构造值对象。

如果聚合创建复杂，推荐使用工厂方法来屏蔽内部复杂的创建逻辑。

聚合内部多个组成对象的关系可以用来指导数据库创建，但不可避免存在一定的抗阻。如聚合中存在List<值对象>，那么在数据库中建立1:N的关联需要将值对象单独建表，此时是有ID的，建议不要将该ID暴露到资源库外部，对外隐蔽。

领域服务

一些重要的领域行为或操作，可以归类为领域服务。它既不是实体，也不是值对象的范畴。

当我们采用了微服务架构风格，一切领域逻辑的对外暴露均需要通过领域服务来进行。如原本由聚合根暴露的业务逻辑也需要依托于领域服务。

领域事件

领域事件是对领域内发生的活动进行的建模。

#### 代码层面的DDD相关的

​	根据上下文的关系，选择对应的处理方式，防腐层（适配层）--这个好像挺难的 
